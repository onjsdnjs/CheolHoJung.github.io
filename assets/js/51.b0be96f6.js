(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{263:function(t,e,s){"use strict";s.r(e);var r=s(1),i=Object(r.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[s("p",[t._v("지난 포스팅에선 객체 내부의 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있는 스테이트 패턴에 대해 알아보았다. 이번엔 객체에 대한 접근을 제어하는 프록시 패턴에 대해 복습한다.")]),t._v(" "),t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),s("lazy-load",{attrs:{tag:"img",data:{src:"/images/posts/2018/3/프록시1.png",alt:"Piece of a Google search page result with the link and a highlight with red borders indicating the URL"}}}),t._v(" "),t._m(4),t._v(" "),s("lazy-load",{attrs:{tag:"img",data:{src:"/images/posts/2018/3/프록시2.png",alt:"Piece of a Google search page result with the link and a highlight with red borders indicating the URL"}}}),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),s("lazy-load",{attrs:{tag:"img",data:{src:"/images/posts/2018/3/프록시3.png",alt:"Piece of a Google search page result with the link and a highlight with red borders indicating the URL"}}}),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),s("lazy-load",{attrs:{tag:"img",data:{src:"/images/posts/2018/3/프록시4.png",alt:"Piece of a Google search page result with the link and a highlight with red borders indicating the URL"}}}),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),s("p",[t._v("원치 않는 접근으로부터 보호해주거나 커다란 객체를 로딩하는 동안 프로그램이 멈추는 것을 방지해 주거나 Subject 객체가 원격 시스템에서 돌아가고 있다는 사실을 숨겨주는 등의 기능을 제공할 수 있다.")]),t._v(" "),t._m(29),t._v(" "),s("p",[t._v("코드를 수정하지 않고도 객체가 할 수 있는 행동을 추가해준다. 구성과 위임을 통해서 실행중에 동적으로 새로운 행동을 추가할 수 있으며 구성요소를 감싸는 데코레이터의 개수에는 제한이 없다.")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/iluwatar/java-design-patterns/tree/master/proxy",target:"_blank",rel:"noopener noreferrer"}},[t._v("프록시 패턴 예제"),s("OutboundLink")],1)])],1)},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"정의"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#정의","aria-hidden":"true"}},[this._v("#")]),this._v(" 정의")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("어떤 객체에 대한 접근을 제어하기 위한 용도로 "),e("strong",[this._v("대리인이나 대변인에 해당하는 객체를 제공하는 패턴.")]),this._v(" 프록시는 다른 객체에 대한 대변자 역할을 한다. 프록시는 "),e("strong",[this._v("자신이 대변하는 객체와 그 객체에 접근하고자 하는 클라이언트 사이에서 여러 가지 방식으로 작업을 처리한다")]),this._v(". 보안을 위해 인터넷을 통해 들어오는 메소드 호출을 쫓아내거나 게으른 객체들을 대신해 끈기있게 기다리는 일을 맡기도 한다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"종류"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#종류","aria-hidden":"true"}},[this._v("#")]),this._v(" 종류")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"원격-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#원격-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 원격 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("원격 프록시는 "),e("strong",[this._v("다른 JVM에 들어있는 객체를 대신하는 로컬 객체")]),this._v("이다. 프록시의 메소드를 호출하면 그 "),e("strong",[this._v("호출이 네트워크를 통해 전달되면서 원격 객체의 메소드가 호출되고 그 결과는 다시 네트워크를 통해 프록시를 거쳐 클라이언트에게 전달된다")]),this._v(". 자바에서는 원격 JVM에 있는 메소드를 호출하기 위해 RMI를 이용한다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Subject는 Proxy 프록시와 RealSubject 주객체가 모두 구현하는 공통 인터페이스이다")]),this._v(". 공통으로 사용하는 인터페이스를 이용해 어떤 클라이언트에서든 프록시를 주 객체하고 똑같이 다룰 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("RealSubject는 작업을 대부분 처리하는 주 객체")]),this._v("이며 "),e("strong",[this._v("Proxy는 주 객체에 대한 접근을 제어한다")]),this._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Proxy에는 작업을 처리하는 주 객체에 대한 래퍼런스가 들어있다")]),this._v(". 클라이언트가 "),e("strong",[this._v("특정 작업을 요청했을 때, 주 객체가 필요하다면 그 래퍼런스를 이용해서 요청을 전달한다")]),this._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"가상-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#가상-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 가상 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("가상 프록시는 생성하는 데 많은 비용이 드는 객체를 대신하는 역할")]),this._v("을 맡는다. 객체가 필요할 때까지 객체의 생성을 미루는 기능도 제공한다. 가상 프록시는 객체를 생성하기 전이나 생성하는 도중에 객체를 대신하기도 하며 객체 생성이 완료되고 나면 그냥 RealSubject에 요청을 직접 전달한다. "),e("strong",[this._v("가상 프록시를 이용하면 생성하기 힘든 자원에 대한 접근을 제어할 수 있다")]),this._v(". 예를 들어 CD 커버를 보여주는 뷰어에서 이미지를 불러오는 동안 무언가 다른 것을 보여주고 싶을 때 가상 프록시를 사용할 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"보호-프록시-동적-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#보호-프록시-동적-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 보호 프록시 (=동적 프록시)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("자바의 reflect 패키지를 이용하면 즉석에서 한 개 이상의 인터페이스를 구현하고 메소드 호출을 지정해 준 클래스에 전달하는 프록시 클래스를 만들 수 있다")]),this._v(". 프록시 클래스가 실행중에 생성되기 때문에 이러한 자바의 기술을 동적 프록시라고 부른다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("동적 프록시는 특이하게도 "),e("strong",[this._v("프록시가 두 개의 클래스로 구성된다")]),this._v(". "),e("strong",[this._v("Proxy 객체에 대한 모든 메소드 호출을 전달 받는 InvocationHandler가 반드시 필요하다")]),this._v(". 이 "),e("strong",[this._v("InvocationHandler에서 RealSubject 객체에 있는 메소드에 대한 접근을 제어한다")]),this._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Proxy 클래스는 자바가 만들어주기 때문에 "),e("strong",[this._v("Proxy에게 어떤 작업을 해야 할지 알려줄 방법이 필요하다")]),this._v(". 하지만 직접 Proxy를 작성할 수 없기 때문에 "),e("strong",[this._v("InvocationHandler를 정의하여 프록시에 대해서 호출되는 모든 메소드에 대해 응답하도록 작성한다. 프록시가 메소드 호출을 요청받으면 InvocationHandler에게 진짜 작업을 요청한다")]),this._v(". 예를 들어 사용자의 권한에 따라 다른 페이지를 보여주고 싶을 때 보호 프록시를 사용할 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"방화벽-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#방화벽-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 방화벽 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("방화벽 프록시는 일련의 네트워크 자원에 대한 접근을 제어함으로써 객체를 공격자로부터 보호해준다")]),this._v(". 방화벽 시스템에서 자주 볼 수 있다. 2017년을 뜨겁게 달군 랜섬웨어의 예방법으로 방화벽 설정이 주목받게 되었다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"스마트-패턴-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#스마트-패턴-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 스마트 패턴 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("스마트 패턴 프록시는 주 객체가 참조될 때마다 추가 행동을 제공한다")]),this._v(". 객체에 대한 래퍼런스의 개수를 세는 것처럼 부가적인 작업을 처리할 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"캐싱-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#캐싱-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 캐싱 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("캐싱 프록시는 비용이 많이 드는 작업의 결과를 임시로 저장해 준다")]),this._v(". 여러 클라이언트에서 결과를 공유하게 해 줌으로써 계산 시간 또는 네트워크 지연을 줄여주는 효과가 있다. 웹 서버 프록시, 컨텐츠 관리 및 퍼블리싱 시스템에서 주로 볼 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"동기화-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#동기화-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 동기화 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("동기화 프록시는 여러 스레드에서 주 객체에 접근하는 경우에 안전하게 작업을 처리할 수 있게 해 준다")]),this._v(". 분산 환경에서 일련의 객체에 대한 동기화된 접근을 제어해주는 자바스페이스에서 볼 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"복잡도-숨김-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#복잡도-숨김-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 복잡도 숨김 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("복잡도 숨김 프록시는 복잡한 클래스들의 집합에 대한 접근을 제어하고, 그 복잡도를 숨겨 준다")]),this._v(". 앞서 일련의 복잡한 서브시스템을 단순화한 퍼사드 패턴이 등장했었다. 복잡도를 숨기기 때문에 퍼사드 프록시라고도 부르지만 "),e("strong",[this._v("퍼사드 패턴이 단순히 대체 인터페이스만 제공하는 것에 비해 복잡도 숨김 프록시는 접근을 제어한다.")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"지연-복사-프록시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#지연-복사-프록시","aria-hidden":"true"}},[this._v("#")]),this._v(" 지연 복사 프록시")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("지연 복사 프록시는 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어한다")]),this._v(". 비용이 큰 객체를 대신하는 가상 프록시와 비슷하므로 변형된 가상 프록시라고 할 수 있다. 자바에서 쓰레드에 대한 안정성을 위해 제공되는 CopyOnWriteArrayList에서 등장한다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"프록시-vs-데코레이터"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#프록시-vs-데코레이터","aria-hidden":"true"}},[this._v("#")]),this._v(" 프록시 VS 데코레이터")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("프록시 패턴은 객체에 대한 접근을 제어하고, 데코레이터 패턴은 객체를 치장하여 기능을 확장한다.")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("프록시 패턴")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("데코레이터 패턴")])])}],!1,null,null,null);i.options.__file="proxy.md";e.default=i.exports}}]);